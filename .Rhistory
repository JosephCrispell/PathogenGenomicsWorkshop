geneticVsEpi <- geneticVsEpi[, -indicesOfMetricsToRemove]
# Update the metrics removed vector
allMetricsRemoved <- c(allMetricsRemoved, metricsRemoved)
}
output <- list(
"clusters" = clusters,
"geneticVsEpiTable" = geneticVsEpi,
"removed" = allMetricsRemoved
)
return(output)
}
noteVariableImportanceOLD <- function(infoRF){
variableImportance <- list()
rowNames <- rownames(infoRF$importance)
for(i in 1:nrow(infoRF$importance)){
variableImportance[[rowNames[i]]] <- infoRF$importance[i, ]
}
return(variableImportance)
}
noteClustersOfMetrics <- function(correlationTable, threshold, defaultColour){
# Create a list to record which clusters metrics are in
clustersForMetrics <- list()
cluster <- 0
# Note the names of the metrics
colNames <- colnames(correlationTable)
# Examine each correlation between the metrics
for(i in 1:nrow(correlationTable)){
for(j in 1:ncol(correlationTable)){
# Skip the diagonal
if(i == j){
next
}
# Check if correlation between the two metrics is above the threshold
if(abs(correlationTable[i,j]) >= threshold){
# Has metric i already been assigned to a cluster?
if(is.null(clustersForMetrics[[colNames[i]]]) == FALSE &&
is.null(clustersForMetrics[[colNames[j]]]) == TRUE){
clustersForMetrics[[colNames[j]]] <- clustersForMetrics[[colNames[i]]]
# Has metric j already been assigned to a cluster?
}else if(is.null(clustersForMetrics[[colNames[j]]]) == FALSE &&
is.null(clustersForMetrics[[colNames[i]]]) == TRUE){
clustersForMetrics[[colNames[i]]] <- clustersForMetrics[[colNames[j]]]
# If neither have, create new cluster
}else if(is.null(clustersForMetrics[[colNames[j]]]) == TRUE &&
is.null(clustersForMetrics[[colNames[i]]]) == TRUE){
cluster <- cluster + 1
clustersForMetrics[[colNames[i]]] <- cluster
clustersForMetrics[[colNames[j]]] <- cluster
# Both already in cluster - check that it is the same
}else if(clustersForMetrics[[colNames[i]]] != clustersForMetrics[[colNames[j]]]){
cat("-------------------------------------------------------------\n")
cat(paste(colNames[i], ":", clustersForMetrics[[colNames[i]]], "\t",
colNames[j], ":", clustersForMetrics[[colNames[j]]], "\n", sep=""))
}
}
}
}
# Summarise the clusters in figure
plotClusterColours(cluster, clustersForMetrics, colNames, threshold, defaultColour)
# Create a list of isolates in each cluster
clusters <- list()
for(metric in colNames){
if(is.null(clustersForMetrics[[metric]]) == FALSE){
# Have we encountered this cluster before?
if(is.null(clusters[[as.character(clustersForMetrics[[metric]])]]) == FALSE){
clusters[[as.character(clustersForMetrics[[metric]])]] <-
append(clusters[[as.character(clustersForMetrics[[metric]])]], metric)
}else{
clusters[[as.character(clustersForMetrics[[metric]])]] <- c(metric)
}
}
}
return(clusters)
}
plotClusterColours <- function(nClusters, clustersForMetrics, metricNames, threshold,
defaultColour){
colourPalette <- colorRampPalette(c("red", "orange", "pink", "brown", "green",
"grey", "cyan", "purple", "violet", "blue"))
colours = colourPalette(nClusters)
#colours <- palette(rainbow(nClusters))
metricColours <- c()
for(i in 1:length(metricNames)){
# Check if metric was assigned to cluster
if(is.null(clustersForMetrics[[metricNames[i]]]) == TRUE){
metricColours[i] <- defaultColour
}else{
metricColours[i] <- colours[clustersForMetrics[[metricNames[i]]]]
}
}
plot.new()
text(x=rep(0.5, length(metricNames)), y=seq(1, 0, -1/(length(metricNames) - 1)),
labels=metricNames,
col=metricColours)
legend("topleft", legend=(1:nClusters), text.col=colours, bty="n")
legend("topright", legend=paste("Threshold =", threshold), bty="n")
}
getFullVariableNames <- function(array, fullNames){
output <- c()
for(i in 1:length(array)){
output[i] <- fullNames[[array[i]]]
if(is.null(fullNames[[array[i]]]) == TRUE){
print(array[i])
}
}
return(output)
}
calculateCorrelationBetweenEpiMetrics <- function(table, fullNames){
# Note columns which are numeric
numericColumns <- which(lapply(table, class) == "numeric")
correlationTable <- round(cor(table[, numericColumns]), digits=2)
plotHeatmap(correlationTable, fullNames)
return(correlationTable)
}
plotHeatmap <- function(correlationTable, fullNames){
colBreaks <- seq(-1, 1, by=0.1)
# Plot the heatmap
heatmap.2(correlationTable, # matrix is the input data
# Show values
cellnote=correlationTable,
notecex=0.75,
notecol="black",
# Create the colour scale
col=colorpanel(n=length(colBreaks)-1, low="blue", mid="white", high="red"),
breaks=colBreaks,
# Turn off a density plot
density.info="none",
# Turn off the trace
trace="none",
# Column Labels
labCol=getFullVariableNames(colnames(correlationTable),
fullNames),
cexCol=0.4, # Change the size of the column labels
srtCol=90, # Set the angle of the column labels (degrees from horizontal)
offsetCol=-0.85, # Set size of space between column labels and heatmap
# Change the size of the margins around the plot: c(column space, row space)
margins = c(20, 20),
# Row labels
labRow=getFullVariableNames(rownames(correlationTable),
fullNames),
cexRow=0.4, # Change the size of the Row labels
offsetRow=0,
# Make sure the order of the rows and columns is changed
Rowv=TRUE, Colv=TRUE,
# Don't plot any dendogram
dendrogram="none",
# Set up the Key
key=FALSE, # Turn the key OFF
# Say where to plot each part of the heatmap
#     4     3
#     2     1
# 1. Heatmap
# 2. Row Dendrogram
# 3. Column Dendrogram
# 4. Key
lmat=rbind(4:3, 2:1),
# Set the size of the spaces for output plots:
#     Colour Key      |   Column Dendrogram
#     -------------------------------------
#     Row Dendrogram  |   Heatmap
#
# Note that these will be affected by the width and height you set for the PDF
lhei=c(0.1, 10), # c(row1Width, row2Width)
lwid=c(0.1, 10), # c(column1Width, column2Width)
# Note that the input matrix is not symmetric
symm = FALSE
)
}
plotPredictedVersusActual <- function(actual, predicted, main="Predicted vs. Actual genetic distances"){
# Plot the predicted versus actual
plot(x=predicted, y=actual,
las=1, pch=19, col=rgb(0,0,0, 0.1), xlab="Predicted", ylab="Actual", main=main)
abline(lm(actual ~ predicted), col="red")
# Calculate the correlation and r squared values
correlation <- cor(actual, predicted)
rSq <- correlation^2
# Add a legend detailing the correlation and r squared values
legend("topleft", c(paste("corr =", round(correlation, digits=2)),
paste("Rsq = ", round(rSq, digits=2))),
bty="n", cex = 1)
}
findOptimalMtry <- function(response, predictors, mTryInitial, nTrees, plot){
tuneOutput <- tuneRF(predictors, response, mtryStart=mTryInitial,
ntreeTry=nTrees, stepFactor=1.5, improve=0.0001, trace=FALSE,
plot=FALSE)
optimalMtry <- as.integer(rownames(tuneOutput)[tuneOutput[,2] == min(tuneOutput[,2])])
if(plot == TRUE){
plot(tuneOutput, las=1)
abline(v=optimalMtry, col="red", lty=2)
}
return(optimalMtry)
}
plotEpidemiologicalMetricDistributionsWithMissingData <- function(table, fullNames,
selection){
# Get the column names of the genetic vs. epi metrics table
colNames <- colnames(table)
# Initialise an array to store the proportion of missing data for each metric
propMissing <- calculateProportionMissingData(table)
# Examine each epidemiological metric
for(col in 1:ncol(table)){
# Check if negative values are present in dataset
if(length(which(as.numeric(table[, col]) < 0)) > 0){
cat(paste("Found ", length(which(table[, col] < 0)), " missing entries for: ",
colNames[col], "\n", sep=""))
# Check if column is a factor
if(is.factor(table[, col]) == TRUE){
plot(table[, col], las=1, main=colNames[col])
}else{
hist(table[, col], las=1, main=colNames[col], xlab="value", breaks=200,
border="black", col="black")
}
}
}
# Get the order by proportion missing data
order <- order(propMissing)
# Get the full names of the metrics
variableNames <- getFullVariableNames(colnames(table), fullNames)
# Get the margin sizes - to fit in metric names
marginSizes <- list(
"BB" = 26,
"CC" = 33,
"CB" = 22,
"BC" = 22
)
par(mar=c(0,marginSizes[[selection]],2,0.5)) # bottom, left, top, right
plot <- barplot(propMissing[order], horiz=TRUE,
beside=TRUE,
main="Proportion Missing Data")
at <- plot[,1]
xLabPosition <- 0
text(labels=variableNames[order],
x=rep(xLabPosition,length(propMissing)),
y=at, srt = 0, pos = 2, xpd = TRUE, cex=0.75)
spacing <- at[2] - at[1]
ticks <- seq(0,1,0.1)
ticks <- ticks[ticks < max(propMissing)]
axis(side=3, at=ticks, line=-spacing*1.2, mgp=c(3, .5, 0))
# Reset margins
par(mar=c(5.1,4.1,4.1,2.1))
}
makeBooleanColumnsFactors <- function(table){
colNames <- colnames(table)
for(col in 1:ncol(table)){
if((grepl(x=colNames[col], pattern="Same") == TRUE &
grepl(x=colNames[col], pattern="PeriodSpentIn") == FALSE) ||
grepl(x=colNames[col], pattern="Boolean") == TRUE){
table[, col] <- as.factor(table[, col])
}
}
return(table)
}
removeColumnsIfNotRelevant <- function(table){
# For particular comparisons: Badger-Badger, Badger-Cattle, Cattle-Cattle
# some epidemiological metrics aren't relevant and column will be filled
# with -1
colsToRemove <- c()
columnsToConsider <- which(colnames(table) %in% c("GeneticDistance", "iSpeciesJSpecies",
"IsolateI", "IsolateJ") == FALSE)
for(col in columnsToConsider){
if(sd(table[, col]) == 0){
colsToRemove[length(colsToRemove) + 1] <- col
cat(paste("Removed: ", colnames(table)[col], "\n", sep=""))
}
}
return(table[, -colsToRemove])
}
source('~/Desktop/Research/GeneralTools/WoodchesterPark/RandomForestAndBoostedRegression/FitRandomForestAndBoostedRegressionToEpiMetrics_BB-CC-CB_10-08-17.R')
source('~/Desktop/Research/GeneralTools/WoodchesterPark/RandomForestAndBoostedRegression/FitRandomForestAndBoostedRegressionToEpiMetrics_BB-CC-CB_10-08-17.R')
source('~/Desktop/Research/GeneralTools/WoodchesterPark/RandomForestAndBoostedRegression/FitRandomForestAndBoostedRegressionToEpiMetrics_BB-CC-CB_10-08-17.R')
data <- data.frame("Name"=c("John", "Evie", "Graham", "Mary"), "Age"=c(13,43,26,17))
data
data <- data.frame("Name"=c("John", "Evie", "Graham", "Mary"), "Age"=c(13,43,26,17))
people <- list()
for(row in 1:nrow(data)){
people[[data[row, "Name"]]] <- data[row, "Age"]
}
people
data[row, "Name"]
data <- data.frame("Name"=c("John", "Evie", "Graham", "Mary"), "Age"=c(13,43,26,17), stringsAsFactors=FALSE)
people <- list()
for(row in 1:nrow(data)){
people[[data[row, "Name"]]] <- data[row, "Age"]
}
people
?assign
data <- data.frame("Name"=c("John", "Evie", "Graham", "Mary"), "Age"=c(13,43,26,17), stringsAsFactors=FALSE)
#people <- list()
for(row in 1:nrow(data)){
#people[[data[row, "Name"]]] <- data[row, "Age"]
assign(x=data[row, "Name"], value=data[row, "Age"])
}
Evie
a <- c(0,"D",0,"E",0,"F")
b <- c(0,"E",0,"F",0,"D")
c <- data.frame(a, b, stringsAsFactors=FALSE)
c
seq(from=1, to=nrow(c), by=2)
row <- 1
c[row, ]
c[row+1, ]
paste0(c[row, ], c[row+1, ])
for(row in seq(from=1, to=nrow(c), by=2)){
c[row, ] <- paste0(c[row+1, ], c[row, ])
}
c
print(c)
Films <- 1:100
Gekeken <- c(2,6,30,45,86,14,22,40,13,15,16)
sample(Films[-Gekeken],1)
Films <- 1:100
Gekeken <- c(2,6,30,45,86,14,22,40,13,15,16)
sample(Films[-Gekeken],1)
Films <- 1:100
Gekeken <- c(2,6,30,45,86,14,22,40,13,15,16)
sample(Films[-Gekeken],1)
Films <- 1:100
Gekeken <- c(2,6,30,45,86,14,22,40,13,15,16)
sample(Films[-Gekeken],1)
Films <- 1:100
Gekeken <- c(2,6,30,45,86,14,22,40,13,15,16)
sample(Films[-Gekeken],1)
Films <- 1:100
Gekeken <- c(2,6,30,45,86,14,22,40,13,15,16)
sample(Films[-Gekeken],1)
data <- data.frame("year"=c(1900, 1901, 1902), "tree1"=c(0.72, 0.56, 1.23), "tree2"=c(0.34, 0.88, 0.56), "tree3"=c(1.34, 0.98, 1.67))
dividebyLag <- function(data, column){
treegrowth[, column] <- treegrowth[, column] / lag(treegrowth[, column])
}
data <- data.frame("year"=c(1900, 1901, 1902), "tree1"=c(0.72, 0.56, 1.23), "tree2"=c(0.34, 0.88, 0.56), "tree3"=c(1.34, 0.98, 1.67))
for(column in colnames(data)[-1]){
data[, column] <- divideByLag(data, column)
}
divideByLag <- function(data, column){
treegrowth[, column] <- treegrowth[, column] / lag(treegrowth[, column])
}
data <- data.frame("year"=c(1900, 1901, 1902), "tree1"=c(0.72, 0.56, 1.23), "tree2"=c(0.34, 0.88, 0.56), "tree3"=c(1.34, 0.98, 1.67))
for(column in colnames(data)[-1]){
data[, column] <- divideByLag(data, column)
}
divideByLag <- function(data, column){
data[, column] <- data[, column] / lag(data[, column])
}
treeGrowth <- data.frame("year"=c(1900, 1901, 1902), "tree1"=c(0.72, 0.56, 1.23), "tree2"=c(0.34, 0.88, 0.56), "tree3"=c(1.34, 0.98, 1.67))
for(column in colnames(treeGrowth)[-1]){
treeGrowth[, column] <- divideByLag(treeGrowth, column)
}
treeGrowth
colnames(treeGrowth)[-1]
treeGrowth <- data.frame("year"=c(1900, 1901, 1902), "tree1"=c(0.72, 0.56, 1.23), "tree2"=c(0.34, 0.88, 0.56), "tree3"=c(1.34, 0.98, 1.67))
for(column in colnames(treeGrowth)[-1]){
treeGrowth[, paste0(column, "_growth")] <- divideByLag(treeGrowth, column)
}
treeGrowth
lag(treeGrowth$tree1)
treeGrowth$tree1
treeGrowth$tree1 / lag(treeGrowth$tree1)
treeGrowth <- data.frame("year"=c(1900, 1901, 1902), "tree1"=c(0.72, 0.56, 1.23), "tree2"=c(0.34, 0.88, 0.56), "tree3"=c(1.34, 0.98, 1.67))
for(column in colnames(treeGrowth)[-1]){
treeGrowth[, paste0(column, "_growth")] <- c(1, treeGrowth[-1, column] / treeGrowth[-nrow(data), column])
}
treeGrowth
getwd()
# Read in the data file
file <- "/home/josephcrispell/Downloads/datasheet.csv"
data <- read.table(file, header=TRUE, sep=",", stringsAsFactors=FALSE)
head(data)
# Plot the data as a line with confidence intervals
plot(x=data$time, y=data$asd)
nrow(data)
# Read in the data file
file <- "/home/josephcrispell/Downloads/datasheet.csv"
data <- read.table(file, header=TRUE, sep=",", stringsAsFactors=FALSE)
# Plot the data as a line with confidence intervals
plot(x=data$time, y=data$asd)
# Plot the data as a line with confidence intervals
plot(x=data$time, y=data$asd, type="l")
# Plot the data as a line with confidence intervals
plot(x=data$time, y=data$asd, type="l", bty="n", las=1)
?polygon
# Add confidence intervals
polygon(x=c(data$time, rev(data$time)), y=c(data$lower, rev(data$upper)))
?polygon
# Plot the data as a line with confidence intervals
plot(x=data$time, y=data$asd, type="l", bty="n", las=1)
# Add confidence intervals
polygon(x=c(data$time, rev(data$time)), y=c(data$lower, rev(data$upper)), border=rgb(0,0,0,0)col=rgb(0,0,0, 0.5))
# Add confidence intervals
polygon(x=c(data$time, rev(data$time)), y=c(data$lower, rev(data$upper)), border=rgb(0,0,0,0), col=rgb(0,0,0, 0.5))
# Plot the data as a line with confidence intervals
plot(x=data$time, y=data$asd, type="l", bty="n", las=1, ylim=range(c(data$asd, data$upper, data$lower)))
# Add confidence intervals
polygon(x=c(data$time, rev(data$time)), y=c(data$lower, rev(data$upper)), border=rgb(0,0,0,0), col=rgb(0,0,0, 0.5))
# Plot the data as a line with confidence intervals
plot(x=data$time, y=data$asd, type="l", bty="n", las=1, ylim=range(c(data$asd, data$upper, data$lower)))
# Add confidence intervals
polygon(x=c(data$time, rev(data$time)), y=c(data$lower, rev(data$upper)), border=rgb(0,0,0,0), col=rgb(0,0,0, 0.5))
# Add confidence intervals
polygon(x=c(data$time, rev(data$time)), y=c(data$lower, rev(data$upper)), border=rgb(0,0,0,0), col=rgb(0,0,0, 0.1))
# Plot the data as a line with confidence intervals
plot(x=data$time, y=data$asd, type="l", bty="n", las=1, ylim=range(c(data$asd, data$upper, data$lower)))
# Add confidence intervals
polygon(x=c(data$time, rev(data$time)), y=c(data$lower, rev(data$upper)), border=rgb(0,0,0,0), col=rgb(0,0,0, 0.1))
# Plot the data as a line with confidence intervals
plot(x=data$time, y=data$asd, type="l", bty="n", las=1, ylim=range(c(data$asd, data$upper, data$lower)))
# Add confidence intervals
polygon(x=c(data$time, rev(data$time)), y=c(data$lower, rev(data$upper)), border=rgb(0,0,0,0), col=rgb(1,0,0, 0.1))
# Plot the data as a line with confidence intervals
plot(x=data$time, y=data$asd, type="l", bty="n", las=1, ylim=range(c(data$asd, data$upper, data$lower)))
# Add confidence intervals
polygon(x=c(data$time, rev(data$time)), y=c(data$lower, rev(data$upper)), border=rgb(0,0,0,0), col=rgb(1,0,0, 1))
# Add confidence intervals
polygon(x=c(data$time, rev(data$time)), y=c(data$lower, rev(data$upper)), border=rgb(0,0,0,0), col=rgb(1,0,1, 0.75))
# Plot the data as a line with confidence intervals
plot(x=data$time, y=data$asd, type="l", bty="n", las=1, ylim=range(c(data$asd, data$upper, data$lower)))
# Add confidence intervals
polygon(x=c(data$time, rev(data$time)), y=c(data$lower, rev(data$upper)), border=rgb(0,0,0,0), col=rgb(1,0,1, 0.75))
# Plot the data as a line with confidence intervals
plot(x=data$time, y=data$asd, type="l", bty="n", las=1, ylim=range(c(data$asd, data$upper, data$lower)))
# Add confidence intervals
polygon(x=c(data$time, rev(data$time)), y=c(data$lower, rev(data$upper)), border=rgb(0,0,0,0), col=rgb(0,0,0, 0.25))
# Add confidence intervals
polygon(x=c(data$time, rev(data$time)), y=c(data$lower, rev(data$upper)), border=rgb(0,0,0,0), col=rgb(0,0,0, 0.25))
# Add confidence intervals
polygon(x=c(data$time, rev(data$time)), y=c(data$lower, rev(data$upper)), border=rgb(0,0,0,0), col=rgb(0,0,0, 0.25))
# Add confidence intervals
polygon(x=c(data$time, rev(data$time)), y=c(data$lower, rev(data$upper)), border=rgb(0,0,0,0), col=rgb(0,0,0, 0.25))
# Add confidence intervals
polygon(x=c(data$time, rev(data$time)), y=c(data$lower, rev(data$upper)), border=rgb(0,0,0,0), col=rgb(0,0,0, 0.25))
# Plot the data as a line with confidence intervals
plot(x=data$time, y=data$asd, type="l", bty="n", las=1, ylim=range(c(data$asd, data$upper, data$lower)))
# Add confidence intervals
polygon(x=c(data$time, rev(data$time)), y=c(data$lower, rev(data$upper)), border=rgb(0,0,0,0), col=rgb(0,0,0, 0.25))
# Plot the data as a line with confidence intervals
plot(x=data$time, y=data$asd, type="l", bty="n", las=1, ylim=range(c(data$asd, data$upper, data$lower)), lwd=2, lty=3)
# Add confidence intervals
polygon(x=c(data$time, rev(data$time)), y=c(data$lower, rev(data$upper)), border=rgb(0,0,0,0), col=rgb(0,0,0, 0.25))
# Set the path variable
path <- "/home/josephcrispell/Desktop/Research/RepublicOfIreland/Mbovis/Monaghan/Fastqs_24-09-19/FASTQC/"
# Read in the FASTQC file summary table
summaryFile <- paste0(path, "Fastqc_summary_24-09-19.txt")
summary <- read.table(summaryFile, header=TRUE, sep="\t", stringsAsFactors=FALSE)
# Look at GC distribution
hist(summary$GC, breaks=20, las=1)
boxplot(summary$LeftTrim, summary$RightTrim, names=c("LEFT", "RIGHT"), las=1, frame=FALSE,
main="Trimming suggestions", outcol=rgb(0,0,0, 0.1), pch=19)
# Check adapter flag
table(summary$AdapterContentFlag)
head(summary])
head(summary)
# Look at the number of reads distribution
hist(summary$NumberReads, breaks=100, las=1)
summary(summary$NumberReads)
summary$FileName[which(summary$NumberReads < 250000)]
summary[which(summary$NumberReads < 250000), c("FileName", "NumberReads")]
# Sort the file names
summary <- summary[order(summary$FileName), ]
# Look at GC distribution
hist(summary$GC, breaks=20, las=1)
boxplot(summary$LeftTrim, summary$RightTrim, names=c("LEFT", "RIGHT"), las=1, frame=FALSE,
main="Trimming suggestions", outcol=rgb(0,0,0, 0.1), pch=19)
# Check adapter flag
table(summary$AdapterContentFlag)
# Look at the number of reads distribution
hist(summary$NumberReads, breaks=100, las=1)
summary[which(summary$NumberReads < 250000), c("FileName", "NumberReads")]
summary[which(summary$NumberReads > 1000000), c("FileName", "NumberReads")]
summary[which(summary$GC != 65), c("FileName", "NumberReads")]
summary[which(summary$GC != 65), c("FileName", "GC")]
# Look at the read length distribution
table(summary$ReadLength)
path <- "/home/josephcrispell/Desktop/Research/RepublicOfIreland/Mbovis/Monaghan/vcfFiles/"
##########################
# Read in coverage files #
##########################
# # Read in the genome coverage file
# genomeCoverageFile <- paste(path, "genomeCoverageSummary_DP-20_21-07-2017.txt", sep="")
# genomeCoverage <- read.table(genomeCoverageFile, header=TRUE, stringsAsFactors=FALSE)
# Read in the isolate coverage file
isolateCoverageFile <- paste(path, "isolateCoverageSummary_DP-20_30-07-2019.txt", sep="")
isolateCoverage <- read.table(isolateCoverageFile, header=TRUE, stringsAsFactors=FALSE)
# Read in the isolate coverage file
isolateCoverageFile <- paste(path, "isolateCoverageSummary_DP-20_24-09-2019.txt", sep="")
isolateCoverage <- read.table(isolateCoverageFile, header=TRUE, stringsAsFactors=FALSE)
# Parse the Isolate column
isolateCoverage$IsolateID <- parseIsolateColumn(isolateCoverage$IsolateID)
parseIsolateColumn <- function(column){
ids <- c()
for(i in 1:length(column)){
parts <- strsplit(column[i], split="_")[[1]]
ids[i] <- paste(parts[1], "_", parts[2], sep="")
}
return(ids)
}
# Parse the Isolate column
isolateCoverage$IsolateID <- parseIsolateColumn(isolateCoverage$IsolateID)
plot(y=isolateCoverage$PercentageCoverage,
x=isolateCoverage$MeanDepth,
las=1, ylab="Proportion", main="Proportion of M. bovis Genome with >19 mapped reads",
xlab="Mean Read Depth", pch=16, cex=3,
col=ifelse(grepl(x=isolateCoverage$IsolateID, pattern="WB"), rgb(1,0,0, 0.5),
rgb(0,0,1, 0.5)))
head(isolateCoverage)
isolateCoverage[isolateCoverage$PercentageCoverage < 0.1, ]
remove.packages("pathogenGenomicsWorkshop")
devtools::install_github("JosephCrispell/pathogeGenomicsWorkshop")
devtools::install_github("JosephCrispell/pathogenGenomicsWorkshop")
remove.packages("pathogenGenomicsWorkshop")
packageDirectory <- "/home/josephcrispell/Desktop/pathogenGenomicsWorkshop/"
setwd(packageDirectory)
document()
library("devtools")
library("roxygen2")
document()
